"""
ARIA — Auto-generated Tool (patched)
Tool name  : extract_from_xml
Description: Extract and parse structured data from XML files into a list of dicts.
             Handles hierarchical XML with attribute propagation (e.g. department → month).

WARNING: Auto-generated by ARIA Tool Builder. Do not edit manually.
"""

from __future__ import annotations


def extract_from_xml(source):
    """
    Extract and parse structured data from XML files into a list of dicts.

    Handles multi-level hierarchies by propagating parent attributes downward.
    Each leaf-level grouping (e.g. <month>) becomes one row, enriched with
    all ancestor attributes (e.g. department name, period id).

    Args:
        source (dict): Dictionary containing:
            - path_or_url (str): Local file path or HTTP(S) URL to an XML file.
            - metadata (dict): Optional metadata (currently unused).

    Returns:
        dict: A dictionary with keys:
            - rows (list[dict]): One dict per leaf record, with all fields flattened.
            - columns (list[str]): List of column names.
    """
    import xml.etree.ElementTree as ET
    import urllib.request
    import urllib.error
    import os
    from io import BytesIO

    path_or_url = source.get('path_or_url')
    if not isinstance(path_or_url, str) or not path_or_url.strip():
        return {'error': 'source.path_or_url must be a non-empty string'}

    # ── Chargement ────────────────────────────────────────────
    try:
        if path_or_url.startswith('http://') or path_or_url.startswith('https://'):
            with urllib.request.urlopen(path_or_url) as resp:
                xml_bytes = resp.read()
            tree = ET.parse(BytesIO(xml_bytes))
        else:
            if not os.path.isfile(path_or_url):
                return {'error': f'File not found: {path_or_url}'}
            tree = ET.parse(path_or_url)
        root = tree.getroot()
    except urllib.error.HTTPError as e:
        return {'error': f'HTTP error fetching URL: {e.code} {e.reason}'}
    except urllib.error.URLError as e:
        return {'error': f'URL error: {e.reason}'}
    except ET.ParseError as e:
        return {'error': f'XML parse error: {e}'}
    except Exception as e:
        return {'error': str(e)}

    # ── Attributs root ────────────────────────────────────────
    root_attrs = {f"report_{k}": v for k, v in root.attrib.items()}

    rows = []

    def flatten_element(elem, inherited: dict) -> list[dict]:
        """
        Parcourt récursivement l'arbre XML.
        - Si l'élément a des enfants qui sont eux-mêmes des conteneurs
          (ont des sous-éléments), on descend récursivement.
        - Si l'élément a des enfants qui sont tous des feuilles (texte seul),
          on crée un enregistrement en fusionnant inherited + attributs + valeurs feuilles.
        """
        # Attributs de cet élément
        current_attrs = dict(inherited)
        for k, v in elem.attrib.items():
            current_attrs[f"{elem.tag}_{k}"] = v

        children = list(elem)

        if not children:
            # Feuille pure → valeur texte
            current_attrs[elem.tag] = (elem.text or '').strip()
            return [current_attrs]

        # Vérifier si les enfants sont des feuilles (aucun petit-enfant)
        all_leaves = all(len(list(child)) == 0 for child in children)

        if all_leaves:
            # C'est un enregistrement terminal : on aplatit les enfants
            record = dict(current_attrs)
            for child in children:
                record[child.tag] = (child.text or '').strip()
            return [record]
        else:
            # Il y a encore des niveaux — on descend récursivement
            result = []
            for child in children:
                result.extend(flatten_element(child, dict(current_attrs)))
            return result

    for child in root:
        rows.extend(flatten_element(child, root_attrs))

    if not rows:
        return {'rows': [], 'columns': []}

    # ── Normalisation : toutes les lignes ont les mêmes colonnes ─
    columns = sorted({k for row in rows for k in row.keys()})
    normalized_rows = [{col: row.get(col, '') for col in columns} for row in rows]

    return {'rows': normalized_rows, 'columns': columns}