"""
ARIA â€” Auto-generated Tool
Tool name  : extract_from_yaml
Description: Extract and parse structured data from YAML files into a list of dicts
Generated  : 2026-02-28T15:04:30.980647

WARNING: Auto-generated by ARIA Tool Builder. Do not edit manually.
"""

from __future__ import annotations

import yaml
import urllib.request
from pathlib import Path
from typing import Dict, Any, List

def extract_from_yaml(source: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract and parse structured data from YAML files into a list of dicts.

    Args:
        source (dict): Dictionary with keys:
            - path_or_url (str): Local file path or remote URL pointing to a YAML file.
            - metadata (dict): Optional additional metadata (ignored).

    Returns:
        dict: Dictionary with keys:
            - rows (list[dict]): Parsed records.
            - columns (list[str]): Unique keys across all rows, in first-appearance order.
    """
    try:
        path_or_url = source.get("path_or_url")
        if not path_or_url:
            raise ValueError("Missing required key 'path_or_url' in source.")

        # Fetch YAML content
        if path_or_url.startswith("http://") or path_or_url.startswith("https://"):
            with urllib.request.urlopen(path_or_url) as response:
                content = response.read().decode("utf-8")
        else:
            content = Path(path_or_url).read_text(encoding="utf-8")

        # Parse YAML
        try:
            parsed = yaml.safe_load(content)
        except yaml.YAMLError as e:
            raise ValueError(f"Invalid YAML: {e}")

        # Normalize parsed data to list[dict]
        if parsed is None:
            parsed = []
        if isinstance(parsed, dict):
            parsed = [parsed]
        if not isinstance(parsed, list):
            raise ValueError("YAML must contain a list or a single mapping.")

        rows = []
        for idx, item in enumerate(parsed):
            if not isinstance(item, dict):
                raise ValueError(f"Item at index {idx} is not a dictionary.")
            rows.append(dict(item))

        # Build ordered list of unique column names
        columns = []
        seen = set()
        for row in rows:
            for key in row:
                if key not in seen:
                    seen.add(key)
                    columns.append(key)

        return {"rows": rows, "columns": columns}

    except Exception as e:
        return {"error": str(e)}
